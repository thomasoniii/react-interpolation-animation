{"version":3,"sources":["examples/ExampleFrame.js","useInterpolate.js","AnimationConsumer.js","Animation.js","constants.js","AnimationGroup.js","Animator.js","examples/Example1.js","examples/Example2.js","examples/Example3.js","examples/Example4.js","examples/Example5.js","examples/Example6.js","examples/Example7.js","examples/Example8.js","examples/Example9.js","App.js","index.js"],"names":["getExampleComponent","code","React","R","Animator","A","AnimationConsumer","AC","useInterpolate","ui","wrappedCode","babelCode","babel","presets","trimmedCode","replace","trim","F","eval","ExampleFrame","blurb","Component","Fragment","className","animatorDefaultEasing","percent","from","to","Math","min","defaultHasChanges","current","previous","undefined","setter","getDelta","duration","getHasChanges","initial","loop","startTime","useRef","performance","now","lastFrame","hasChanges","frame","cancelAnimationFrame","delta","useEffect","prevVals","requestAnimationFrame","animate","time","newDelta","render","ANIMATOR_INITIAL","Animation","values","child","easing","defaultEasing","reduce","bucket","v","props","fullInitial","childInit","forEach","useState","localValues","setLocalValues","c","Boolean","Object","keys","find","key","newValue","value","cloneElement","AnimationGroup","args","children","Children","map","count","only","Example1","Example2","Example3","Example4","ExampleNUMBER","Example6","Example7","Example9","App","style","gridColumnStart","href","target","rel","Example8","Example5","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4e06b7d1.chunk.js","sourcesContent":["import PropTypes from \"prop-types\"\nimport * as babel from \"babel-standalone\"\n\nimport R from \"react\"\nimport A from \"../Animator\"\nimport AC from \"../AnimationConsumer\"\nimport ui from \"../useInterpolate\"\n\nconst getExampleComponent = (\n  code,\n  // eslint-disable-next-line\n  { React = R, Animator = A, AnimationConsumer = AC, useInterpolate = ui } = {}\n) => {\n  const wrappedCode = `() => {\n    ${code}\n  }`\n\n  const babelCode = babel.transform(wrappedCode, {\n    presets: [\"react\", \"es2015\"],\n  }).code\n\n  const trimmedCode = babelCode.replace('\"use strict\";', \"\").trim()\n\n  const F = eval(trimmedCode)\n\n  return F\n}\n\nconst ExampleFrame = ({ blurb, code }) => {\n  const Component = getExampleComponent(code)\n\n  return (\n    <R.Fragment>\n      <div className=\"code\">\n        <div>{blurb}</div>\n        <code>{code}</code>\n      </div>\n      <div className=\"example\">\n        <Component />\n      </div>\n    </R.Fragment>\n  )\n}\n\nExampleFrame.propTypes = {\n  blurb: PropTypes.string,\n  code: PropTypes.string,\n}\n\nexport default ExampleFrame\n","import { useRef, useEffect } from \"react\"\n\n/*\n  This is the meat of the library.\n  Set it up in your component like this:\n\n  const SomeReactComponent( { someValue } ) => {\n\n    // make a local copy of the variable that you're going to interpolate.\n    const [interpolatedSomeValue, setInterpolatedSomeValue] = useState(someValue);\n\n    // and then actually interpolate it.\n    useInterpolate(someValue, setInterpolatedSomeValue)\n\n    // later, when you would have done this:\n    // <div width = {someValue}>Some DIV element</div>\n    // instead do this:\n    <div width={interpolatedSomeValue}>Some DIV element</div>\n\n    // And you are done.\n  }\n\n  There is a third argument - an options object which you can pass along:\n\n    getDelta - should be a function which accepts a single object, which contains\n      three values - { to, from, percent }\n      to is the value at the start of the interpolation\n      from is the value at the end of the interpolation\n      percent is a float from 0->1 showing how far along the animation we are.\n      Pass this arg to change easing speed or animation effects, such as to use\n      a quadratic ease function or animate text typing.\n\n    duration - length of the animation in ms\n\n    getHasChanges - a function to determine if there are changes to the values.\n      should accept an object with two keys - current and previous\n      current is an object with key/value mapping at the end of the interpolation.\n      previous is an object with key/value mapping when the interpolation started.\n\n    initial - sometimes you want an interpolation to start from a different value\n      than the one initially set on the component when it is first mounted.\n      You can pass in a set of initial values to use here.\n\n    loop - repeat the animation from the beginning the specified number of times.\n      e.g., 5 repeats 5x, 10 repeats 10x.\n      0 is the default where it will not repeat.\n      -1 repeats infinite times.\n\n      Again, rememeber, it loops from the beginning.\n\n*/\n\n/*\n  The default delta easing. Given percent, from, and to.\n  Returns a value between from and to, at a given percentage, with linear easing.\n\n  e.g.,\n  animatorDefaultEasing({from : 50, to : 100, percent : .5})\n  // returns 75, since it's halfway between 50 and 100.\n\n  You can use this function if it is useful to you, and otherwise provide your own.\n*/\nexport const animatorDefaultEasing = ({ percent, from, to }) => {\n  return from + Math.min(1, percent) * (to - from)\n}\n\n/*\n  By default, if we have no previous values, we have no changes.\n  otherwise, if the two objects are not identical, we have changes.\n*/\nconst defaultHasChanges = (current, previous) =>\n  previous !== undefined && current !== previous\n\nconst useInterpolate = (\n  current,\n  setter,\n  {\n    getDelta = animatorDefaultEasing,\n    duration = 500,\n    getHasChanges = defaultHasChanges,\n    initial,\n    loop = 0,\n  } = {}\n) => {\n  // requestAnimationFrame starts ticking as soon as the page is loaded. We'll need\n  // to do conversions between absolute page load time vs relative interpolation time.\n  const startTime = useRef(performance.now())\n\n  // keep track of the last set of values at the start of the interpolation, defaulting\n  // to the initial values.\n  const previous = useRef(initial)\n\n  // keep track of the last frame of animation, in case we want to cancel it.\n  const lastFrame = useRef({})\n\n  // and further key each animation so we won't accidentally re-run something.\n  // const renderKey = useRef(1)\n\n  const hasChanges = getHasChanges(current, previous.current)\n\n  // if we have changes and are re-interpolating AND an animation frame is pending,\n  // then cancel it out and set our \"last\" values to wherever the interpolation had\n  // moved us to at that point. Then wipe out our lastFrame.\n  if (hasChanges && lastFrame.current.frame) {\n    cancelAnimationFrame(lastFrame.current.frame)\n    previous.current = lastFrame.current.delta\n    lastFrame.current = {}\n  }\n\n  // we enter the effect when hasChanges has changed.\n  useEffect(() => {\n    // blank out our last startTime, since we'll rewrite it in the animation frame.\n    startTime.current = undefined\n\n    // keep a ref to our previous values.\n    const prevVals = previous.current\n\n    // and increment our renderKey.\n    // const myKey = renderKey.current++\n\n    // the effect fires if hasChanges has changed. But we don't actually want to\n    // fire the animation unless hasChanges is actually true.\n    if (hasChanges) {\n      // request an animation frame and save it.\n      lastFrame.current.frame = requestAnimationFrame(function animate(time) {\n        // this is disabled for now for more testing.\n        /*\n        if (myKey !== renderKey.current) {\n          return;\n        }\n        //*/\n\n        // save the startTime on the first frame if we need to.\n        startTime.current = startTime.current || time\n\n        // and convert from absolute page time to relative interpolation time.\n        time -= startTime.current\n\n        // if our current time < duration, we're still interpolating.\n        // get newDelta values, call the setter with them, and save them along\n        // with requesting a new frame.\n        if (time < duration || loop--) {\n          // if (time < duration) {\n          const newDelta = getDelta({\n            from: prevVals,\n            to: current,\n            percent: time / duration,\n          })\n\n          setter(() => newDelta)\n          lastFrame.current.delta = newDelta\n\n          lastFrame.current.frame = requestAnimationFrame(animate)\n\n          if (loop && time >= duration) {\n            previous.current = prevVals\n            startTime.current = undefined\n          }\n        } else {\n          // otherwise, we've the duration. So we just call the setter with our final\n          // values, update our previous value, and wipe out the last frame.\n          setter(() => current)\n          previous.current = current\n          lastFrame.current = {}\n        }\n      })\n    }\n\n    // always save the new current values as the previous ones whenever we enter.\n    previous.current = current\n    // eslint-disable-next-line\n  }, [hasChanges]);\n}\n\nexport default useInterpolate\n","/*\n  very simple component, just around as a reflector. Takes a render prop, then hands\n  all props it was given through to that render prop.\n\n  This is useful for cases where you want to provide an interpolated value to a child\n  component, but NOT as a prop of that component.\n\n  Or just roll your own flavor of this, I'm not your dad.\n*/\nconst AnimationConsumer = ({ render, ...props }) => {\n  return render(props)\n}\n\nexport default AnimationConsumer\n","import React, { useState } from \"react\"\nimport useInterpolate, { animatorDefaultEasing } from \"./useInterpolate\"\n\nimport { DEFAULT_DURATION } from \"./constants\"\n\n/*\n  I'm playing around with how I want to structure this code.\n  For now, an Animation is identical to an AnimationGroup, except it only accepts\n  one component via a render prop instead of a list of children.\n\n  You probably don't want to use this directly and probably want to import Animator\n  instead.\n\n  In fact, go look at the more thorough documentation over in Animator.\n*/\n\nconst ANIMATOR_INITIAL = \"animator-initial\"\n\nconst Animation = ({\n  values = [],\n  duration = DEFAULT_DURATION,\n  child,\n  easing = {},\n  defaultEasing = animatorDefaultEasing,\n  initial = {},\n  loop = 0,\n}) => {\n  // given our values array, look to the child to figure out our current values.\n  const current = values.reduce((bucket, v) => {\n    return { ...bucket, [v]: child.props[v] }\n  }, {})\n\n  // we're going to build a new initial object\n  const fullInitial = {}\n  // pull out any initial values set on the child\n  const childInit = child.props[ANIMATOR_INITIAL] || {}\n\n  // now iterate over our values (which is a list of keys)\n  // and set the initial value to the child's init value, our component init value, or the\n  // child's current prop value.\n  values.forEach((v) => {\n    fullInitial[v] = childInit[v] ?? initial[v] ?? current[v]\n  })\n\n  // standard useInterpolate call - save localValues to hand through to the child.\n  const [localValues, setLocalValues] = useState(fullInitial)\n  useInterpolate(current, setLocalValues, {\n    // here we have changes if any key in our current set of values has changed from\n    // our last set of values.\n    //\n    // remember - this is not all props on the child, this is just the props in our\n    // values array.\n    getHasChanges: (c, previous) =>\n      Boolean(\n        Object.keys(c).find((key) => previous && c[key] !== previous[key])\n      ),\n\n    duration,\n\n    initial: fullInitial,\n\n    loop,\n\n    // our getDelta function needs to construct a new object with each value interpolated\n    // along the way.\n    getDelta: ({ percent, from, to }) => {\n      return Object.keys(to).reduce((bucket, v) => {\n        const easingFunc = easing[v] || defaultEasing\n        const newValue = easingFunc({\n          from: from[v],\n          to: to[v],\n          percent,\n          value: v,\n        })\n        return {\n          ...bucket,\n          [v]: newValue,\n        }\n      }, {})\n    },\n  })\n\n  // finally, we're going to clone the child with the new props\n  // but toss out the animator-initial value: we don't need it any more and don't\n  // want it writing to the DOM.\n  return React.cloneElement(child, {\n    ...localValues,\n    [ANIMATOR_INITIAL]: undefined,\n  })\n}\n\nexport default Animation\n","export const DEFAULT_DURATION = 500\n","/*\n  I'm playing around with how I want to structure this code.\n  For now, an AnimationGroup is identical to an Animation, except it allows you\n  to vend an animation out to multiple children. Animation only vends to one.\n\n  You probably don't want to use this directly and probably want to import Animator\n  instead.\n\n  In fact, go look at the more thorough documentation over in Animator.\n*/\n\nimport React from \"react\"\nimport Animation from \"./Animation\"\n\nconst AnimationGroup = (props) => {\n  const args = { ...props }\n  delete args.children\n  return React.Children.map(props.children, (child) => (\n    <Animation {...args} child={child} />\n  ))\n}\n\nexport default AnimationGroup\n","import React from \"react\"\nimport Animation from \"./Animation\"\nimport AnimationGroup from \"./AnimationGroup\"\n\nimport { DEFAULT_DURATION } from \"./constants\"\n\n/*\n  I'm playing around with how I want to structure this code.\n  For now, just use Animator and it'll work with as many children as you pass it,\n  deferring the actual work to an Animation or AnimationGroup component.\n\n  Say you have this element in an SVG graphic:\n  <rect x = {0} y = {10} width = {width} height = {10} fill = \"blue\" />\n\n  And you want to animate that width value, so when you change the value, the bar\n  animates to the new size. All you need to do is wrapper it with an Animator.\n\n  <Animator values = {[\"width\"]}>\n    <rect x = {x} y = {y} width = {width} height = {10} fill = \"blue\" />\n  </Animator>\n\n  If you want to animate all of those variables:\n  <Animator values = {[\"width\", \"x\", \"y\"]}>\n    <rect x = {x} y = {y} width = {width} height = {10} fill = \"blue\" />\n  </Animator>\n\n  Now if any (or all!) of x, y, or width change, it'll animate to the new position.\n\n  Animator (and the other verions it wrappers) accepts several props:\n\n    values - an array of strings to watch for changes. These props MUST be named\n      on the child components for them to be handed through.\n    duration - length of the interpolation duration in ms. Defaults to 500\n    easing - an object of { [value] : easingFunction }\n      the easingFunction is the same as the getDelta function in useInterpolate.\n      Accepts an arg of a single object of {from, to, percent}\n    defaultEasing - change the default easing used if a specific easing for a given\n      value is not provided.\n    initial - an object containing { [value] : initialValue } This is optional.\n      The initial object is used if you want to start from a different position.\n\n      For example:\n        <Animator values = {[\"x\"]}>\n          <rect x = {x} y = {0} width = {50} height = {50} />\n        </Animator>\n\n      Let's say the first time you mount the component, x = 50. It will draw immediately\n      at x ={50} w/o animation.\n\n      initial is used to provide that first transition into the DOM.\n        <Animator values = {[\"x\"]} initial = {{x : 0}}>\n          <rect x = {x} y = {0} width = {50} height = {50} />\n        </Animator>\n      This will mount the component with an x value of 0 and then interpolate it until it\n      reaches 50.\n\n      This is to keep your data value (which is x = 50) separate from a sugared animation value\n      (have it fly in from 0)\n\n    It's possible that child components should animate starting at different positions.\n    Animator looks for a prop on its children called `animator-initial`. If present, initial\n    values in there will be used.\n\n    The precedence for an intial value is:\n      child.animator-initial[value]\n      Animator.initial[value]\n      child.props[value]\n\n*/\n\nconst Animator = (props) => {\n  const args = {\n    duration: DEFAULT_DURATION,\n    ...props,\n  }\n\n  return React.Children.count(args.children) > 1 ? (\n    <AnimationGroup {...args} />\n  ) : (\n    <Animation {...args} child={React.Children.only(args.children)} />\n  )\n}\n\nexport default Animator\n","import React from \"react\"\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb = \"Let's start with a simple example, an SVG with a box in it.\"\nconst code = `\n  return (\n    <svg\n      viewBox=\"0 0 100 100\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"100\"\n      height=\"100\"\n    >\n      <rect x=\"10\" y=\"10\" width=\"25\" height=\"25\" fill=\"blue\" />\n    </svg>\n  )\n`\n\nconst Example1 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example1\n","import React from \"react\"\n\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb = `Now we'll make it interactive, but not use\n    react-interpolation-animation. Just give it a text field and a button\n    for the user to change the value. This works, but there is no\n    animation so it may be jarring.`\n\nconst code = `\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        <rect x=\"10\" y=\"10\" width={width} height=\"25\" fill=\"blue\" />\n      </svg>\n      <div>\n        <input\n          type=\"text\"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(e.target.value)}\n        />\n        <button onClick={() => setWidth(parseInt(tempWidth, 10))}>\n          Update width\n        </button>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst Example2 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example2\n","import React from \"react\"\n\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb = `Fortunately, this is exactly what our <Animator> component does.\n    Just wrap the rect in Animator and watch the width smoothly\n    transition.`\n\nconst code = `\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        <Animator values={[\"width\"]}>\n          <rect x=\"10\" y=\"10\" width={width} height=\"25\" fill=\"blue\" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type=\"text\"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <button onClick={() => setWidth(tempWidth)}>Update width</button>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst Example3 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example3\n","import React from \"react\"\n\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb = `But you can also animate multiple values at once!`\n\nconst code = `\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n  const [height, setHeight] = React.useState(25)\n  const [tempHeight, setTempHeight] = React.useState(height)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        /* simply pass the \"height\" key here to interpolate on it. If\n        height is not specified, then the width would animate but the height\n        would jump. */\n        <Animator values={[\"width\", \"height\"]}>\n          <rect x=\"10\" y=\"10\" width={width} height={height} fill=\"blue\" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type=\"text\"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <input\n          type=\"text\"\n          value={tempHeight}\n          onChange={(e) => setTempHeight(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setWidth(tempWidth)\n            setHeight(tempHeight)\n          }}\n        >\n          Update dimensions\n        </button>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst Example4 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example4\n","import React from \"react\"\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb =\n  \"The AnimationConsumer can help you pass values to children, even if the child doesn't use the animated prop directly.\"\nconst code = `\n  const [rotate, setRotate] = React.useState(0)\n  const [tempRotate, setTempRotate] = React.useState(rotate)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        /* Set up an Animator on rotate, as usual. Then let the\n        AnimationConsumer pass that rotate prop onto its children, who can use\n        it to build a string, in this case. */\n        <Animator values={[\"rotate\"]}>\n          <AnimationConsumer\n            rotate={rotate}\n            render={({ rotate }) => (\n              <g transform={\\`rotate(\\${rotate},25,25)\\`}>\n                <rect x=\"10\" y=\"10\" width=\"30\" height=\"30\" fill=\"blue\" />\n              </g>\n            )}\n          />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type=\"text\"\n          value={tempRotate}\n          onChange={(e) => setTempRotate(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setRotate(tempRotate)\n          }}\n        >\n          Update rotation\n        </button>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst ExampleNUMBER = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default ExampleNUMBER\n","import React from \"react\"\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb =\n  \"Custom easing functions can let you interpolate any values. Let's animate some text typing!\"\nconst code = `\n  const [text, setText] = React.useState(\"This is some sample text\")\n  const [tempText, setTempText] = React.useState(text)\n\n  return (\n    <React.Fragment>\n      <div>\n        <input\n          type=\"text\"\n          value={tempText}\n          onChange={(e) => setTempText(e.target.value)}\n        />\n        <button\n          onClick={() => {\n            setText(tempText)\n          }}\n        >\n          Update text\n        </button>\n      </div>\n      <div>\n        <Animator\n          values={[\"text\"]}\n          duration={5000}\n          defaultEasing={({ from, to, percent }) => {\n            let i = 0\n            while (from.charAt(i) === to.charAt(i)) {\n              i++\n            }\n            if (percent < 0.5) {\n              return from.substr(\n                0,\n                i + Math.floor((1 - percent * 2) * (from.length - i))\n              )\n            } else {\n              return to.substr(\n                0,\n                i + Math.floor((percent - 0.5) * 2 * (to.length - i))\n              )\n            }\n          }}\n        >\n          <AnimationConsumer\n            text={text}\n            render={({ text }) => <span>{text}</span>}\n          />\n        </Animator>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst Example6 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example6\n","import React from \"react\"\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb =\n  \"The useInterpolate hook may make sense for your project, if you want to handle animation completely within a component.\"\nconst code = `\n  const MyRef = React.useRef(({ x, y, width = 25, height = 25, fill = \"blue\" }) => {\n    const [interpolatedX, setInterpolatedX] = React.useState(x)\n    useInterpolate(x, setInterpolatedX)\n\n    const [interpolatedY, setInterpolatedY] = React.useState(y)\n    useInterpolate(y, setInterpolatedY)\n\n    return (\n      <rect\n        x={interpolatedX}\n        y={interpolatedY}\n        width={width}\n        height={height}\n        fill={fill}\n      />\n    )\n  })\n  const MyRect = MyRef.current\n\n  const [x, setX] = React.useState(10)\n  const [tempX, setTempX] = React.useState(x)\n  const [y, setY] = React.useState(10)\n  const [tempY, setTempY] = React.useState(y)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        <MyRect x={x} y={y} />\n      </svg>\n      <div>\n        <input\n          type=\"text\"\n          value={tempX}\n          onChange={(e) => setTempX(parseInt(e.target.value, 10))}\n        />\n        <input\n          type=\"text\"\n          value={tempY}\n          onChange={(e) => setTempY(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setX(tempX)\n            setY(tempY)\n          }}\n        >\n          Update coordinates\n        </button>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst Example7 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example7\n","import React from \"react\"\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb = \"You can also animate across multiple children\"\nconst code = `\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n  const [height, setHeight] = React.useState(25)\n  const [tempHeight, setTempHeight] = React.useState(height)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        /* Pass multiple children into the Animator to interpolate them all on\n        the same props. */\n        <Animator values={[\"width\", \"height\"]}>\n          <rect x=\"10\" y=\"10\" width={width} height={height} fill=\"blue\" />\n          <rect x=\"20\" y=\"50\" width={width} height={height} fill=\"red\" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type=\"text\"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <input\n          type=\"text\"\n          value={tempHeight}\n          onChange={(e) => setTempHeight(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setWidth(tempWidth)\n            setHeight(tempHeight)\n          }}\n        >\n          Update dimensions\n        </button>\n      </div>\n    </React.Fragment>\n  )\n`\n\nconst Example9 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example9\n","import React from \"react\"\n\nimport ExampleFrame from \"./ExampleFrame\"\n\nconst blurb = `You can set the loop flag to re-run your interpolation.`\n\nconst code = `\n  const [width, setWidth] = React.useState(25);\n  const [tempWidth, setTempWidth] = React.useState(width);\n  const [loop, setLoop] = React.useState(0);\n  const [tempLoop, setTempLoop] = React.useState(loop);\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox=\"0 0 100 100\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"100\"\n        height=\"100\"\n      >\n        /* Just set the loop parameter on Animator or pass in a loop value to useInterpolate's options arg.\n           0 is the default - run it once and done.\n           -1 will loop infinitely.\n           >0 will re-run the interpolation that number of times (e.g., 5 will run 5x)\n\n           NOTE - if you are running infinitely, you will need to change the interpolated value AND the loop\n           value in order to break out of the loop.\n        */\n        <Animator values={[\"width\"]} loop={loop}>\n          <rect x=\"10\" y=\"10\" width={width} height=\"25\" fill=\"blue\" />\n        </Animator>\n      </svg>\n      <div>\n        Loop:\n        <input\n          type=\"text\"\n          value={tempLoop}\n          onChange={(e) => setTempLoop(e.target.value)}\n        />\n      </div>\n      <div>\n        <input\n          type=\"text\"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(e.target.value)}\n        />\n        <button\n          onClick={() => {\n            setLoop(parseInt(tempLoop, 10));\n            setWidth(parseInt(tempWidth, 10));\n          }}\n        >\n          Update width\n        </button>\n      </div>\n    </React.Fragment>\n  );\n`\n\nconst Example9 = () => {\n  return <ExampleFrame blurb={blurb} code={code} />\n}\n\nexport default Example9\n","import React from \"react\"\n\nimport Example1 from \"./examples/Example1\"\nimport Example2 from \"./examples/Example2\"\nimport Example3 from \"./examples/Example3\"\nimport Example4 from \"./examples/Example4\"\nimport Example5 from \"./examples/Example5\"\nimport Example6 from \"./examples/Example6\"\nimport Example7 from \"./examples/Example7\"\nimport Example8 from \"./examples/Example8\"\nimport Example9 from \"./examples/Example9\"\n\nimport \"./App.css\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div style={{ gridColumnStart: \"span 2\" }} className=\"header\">\n        Here are some examples of what you can do with{\" \"}\n        <a\n          href=\"https://github.com/thomasoniii/react-interpolation-animation\"\n          target=\"_blank\"\n          rel=\"noreferrer\"\n        >\n          react-interpolation-animation\n        </a>\n        .\n      </div>\n      <Example1 />\n      <Example2 />\n      <Example3 />\n      <Example4 />\n      <Example8 />\n\n      <Example5 />\n      <Example6 />\n      <Example7 />\n      <Example9 />\n\n      <div style={{ gridColumnStart: \"span 2\" }} className=\"header\">\n        <div>\n          And that&apos;s it! Have fun, and read the source if you get stuck -\n          there are lots of comments as well as additional options that you can\n          use to govern easing functions, initial values, and duration.\n        </div>\n        <div>\n          Use either the HOC wrapper or the hook - go with whatever works\n          easiest for your project. Enjoy!\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport App from \"./App\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}