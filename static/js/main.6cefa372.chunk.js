(this["webpackJsonpreact-interpolation-animation"]=this["webpackJsonpreact-interpolation-animation"]||[]).push([[0],[,,function(module,__webpack_exports__,__webpack_require__){"use strict";var babel_standalone__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(8),babel_standalone__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(babel_standalone__WEBPACK_IMPORTED_MODULE_0__),react__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(1),react__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__),_Animator__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(11),_AnimationConsumer__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(9),_useInterpolate__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(5),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(0),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5___default=__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__),getExampleComponent=function getExampleComponent(code){var _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},_ref$React=_ref.React,React=void 0===_ref$React?react__WEBPACK_IMPORTED_MODULE_1___default.a:_ref$React,_ref$Animator=_ref.Animator,Animator=void 0===_ref$Animator?_Animator__WEBPACK_IMPORTED_MODULE_2__.a:_ref$Animator,_ref$AnimationConsume=_ref.AnimationConsumer,AnimationConsumer=void 0===_ref$AnimationConsume?_AnimationConsumer__WEBPACK_IMPORTED_MODULE_3__.a:_ref$AnimationConsume,_ref$useInterpolate=_ref.useInterpolate,useInterpolate=void 0===_ref$useInterpolate?_useInterpolate__WEBPACK_IMPORTED_MODULE_4__.b:_ref$useInterpolate;if("function"===typeof code)return code;var wrappedCode="() => {\n    ".concat(code,"\n  }"),babelCode=babel_standalone__WEBPACK_IMPORTED_MODULE_0__.transform(wrappedCode,{presets:["react","es2015"]}).code,trimmedCode=babelCode.replace('"use strict";',"").trim(),F=eval(trimmedCode);return F},ExampleFrame=function(t){var e=t.blurb,n=t.code,a=getExampleComponent(n);return"function"===typeof n&&(n="Code is function"),Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment,{children:[Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)("div",{className:"code",children:[Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div",{children:e}),Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("code",{children:n})]}),Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)("div",{className:"example",children:Object(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(a,{})})]})};__webpack_exports__.a=ExampleFrame},,,function(t,e,n){"use strict";n.d(e,"a",(function(){return i}));var a=n(1),i=function(t){var e=t.percent,n=t.from,a=t.to;return n+Math.min(1,e)*(a-n)},o=function(t,e){return void 0!==e&&t!==e};e.b=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.getDelta,s=void 0===r?i:r,c=n.duration,u=void 0===c?500:c,l=n.getHasChanges,h=void 0===l?o:l,d=n.initial,p=n.loop,m=void 0===p?0:p,_=n.onCompleteCallback,g=void 0===_?function(){}:_,v=Object(a.useRef)(performance.now()),b=Object(a.useRef)(d),w=Object(a.useRef)({}),f=h(t,b.current);f&&w.current.frame&&(cancelAnimationFrame(w.current.frame),b.current=w.current.delta||d,w.current={}),Object(a.useEffect)((function(){v.current=void 0;var n=b.current;f&&(w.current.frame=requestAnimationFrame((function a(i){if(v.current=v.current||i,(i-=v.current)<u||m--){var o=s({from:n,to:t,percent:i/u});e((function(){return o})),w.current.delta=o,w.current.frame=requestAnimationFrame(a),m&&i>=u&&(b.current=n,v.current=void 0)}else e((function(){return t})),b.current=t,w.current={},g({from:n,to:t})}))),b.current=t}),[f])}},,,,function(t,e,n){"use strict";var a=n(12),i=["render"];e.a=function(t){return(0,t.render)(Object(a.a)(t,i))}},,function(t,e,n){"use strict";var a=n(3),i=n(1),o=n.n(i),r=n(10),s=n(4),c=n(5),u="animator-initial",l=function(t){var e=t.values,n=void 0===e?[]:e,l=t.duration,h=void 0===l?500:l,d=t.child,p=t.easing,m=void 0===p?{}:p,_=t.defaultEasing,g=void 0===_?c.a:_,v=t.initial,b=void 0===v?{}:v,w=t.loop,f=void 0===w?0:w,x=t.onCompleteCallback,j=n.reduce((function(t,e){return Object(a.a)(Object(a.a)({},t),{},Object(s.a)({},e,d.props[e]))}),{}),O={},R=d.props[u]||{};n.forEach((function(t){var e,n;O[t]=null!==(e=null!==(n=R[t])&&void 0!==n?n:b[t])&&void 0!==e?e:j[t]}));var C=Object(i.useState)(O),E=Object(r.a)(C,2),y=E[0],W=E[1];return Object(c.b)(j,W,{getHasChanges:function(t,e){return Boolean(Object.keys(t).find((function(n){return e&&t[n]!==e[n]})))},duration:h,initial:O,loop:f,getDelta:function(t){var e=t.percent,n=t.from,i=t.to;return Object.keys(i).reduce((function(t,o){var r=(m[o]||g)({from:n[o],to:i[o],percent:e,value:o});return Object(a.a)(Object(a.a)({},t),{},Object(s.a)({},o,r))}),{})},onCompleteCallback:x}),o.a.cloneElement(d,Object(a.a)(Object(a.a)({},y),{},Object(s.a)({},u,void 0)))},h=n(0),d=function(t){var e=Object(a.a)({},t);return delete e.children,o.a.Children.map(t.children,(function(t){return Object(h.jsx)(l,Object(a.a)(Object(a.a)({},e),{},{child:t}))}))};e.a=function(t){var e=Object(a.a)({duration:500},t);return o.a.Children.count(e.children)>1?Object(h.jsx)(d,Object(a.a)({},e)):Object(h.jsx)(l,Object(a.a)(Object(a.a)({},e),{},{child:o.a.Children.only(e.children)}))}},,,,,,,function(t,e,n){},function(t,e,n){"use strict";n.r(e);var a=n(1),i=n.n(a),o=n(7),r=n.n(o),s=n(2),c=n(0),u=function(){return Object(c.jsx)(s.a,{blurb:"Let's start with a simple example, an SVG with a box in it.",code:'\n  return (\n    <svg\n      viewBox="0 0 100 100"\n      xmlns="http://www.w3.org/2000/svg"\n      width="100"\n      height="100"\n    >\n      <rect x="10" y="10" width="25" height="25" fill="blue" />\n    </svg>\n  )\n'})},l=function(){return Object(c.jsx)(s.a,{blurb:"Now we'll make it interactive, but not use\n    react-interpolation-animation. Just give it a text field and a button\n    for the user to change the value. This works, but there is no\n    animation so it may be jarring.",code:'\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        <rect x="10" y="10" width={width} height="25" fill="blue" />\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(e.target.value)}\n        />\n        <button onClick={() => setWidth(parseInt(tempWidth, 10))}>\n          Update width\n        </button>\n      </div>\n    </React.Fragment>\n  )\n'})},h=function(){return Object(c.jsx)(s.a,{blurb:"Fortunately, this is exactly what our <Animator> component does.\n    Just wrap the rect in Animator and watch the width smoothly\n    transition.",code:'\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        <Animator values={["width"]}>\n          <rect x="10" y="10" width={width} height="25" fill="blue" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <button onClick={() => setWidth(tempWidth)}>Update width</button>\n      </div>\n    </React.Fragment>\n  )\n'})},d=function(){return Object(c.jsx)(s.a,{blurb:"But you can also animate multiple values at once!",code:'\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n  const [height, setHeight] = React.useState(25)\n  const [tempHeight, setTempHeight] = React.useState(height)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        /* simply pass the "height" key here to interpolate on it. If\n        height is not specified, then the width would animate but the height\n        would jump. */\n        <Animator values={["width", "height"]}>\n          <rect x="10" y="10" width={width} height={height} fill="blue" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <input\n          type="text"\n          value={tempHeight}\n          onChange={(e) => setTempHeight(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setWidth(tempWidth)\n            setHeight(tempHeight)\n          }}\n        >\n          Update dimensions\n        </button>\n      </div>\n    </React.Fragment>\n  )\n'})},p=function(){return Object(c.jsx)(s.a,{blurb:"The AnimationConsumer can help you pass values to children, even if the child doesn't use the animated prop directly.",code:'\n  const [rotate, setRotate] = React.useState(0)\n  const [tempRotate, setTempRotate] = React.useState(rotate)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        /* Set up an Animator on rotate, as usual. Then let the\n        AnimationConsumer pass that rotate prop onto its children, who can use\n        it to build a string, in this case. */\n        <Animator values={["rotate"]}>\n          <AnimationConsumer\n            rotate={rotate}\n            render={({ rotate }) => (\n              <g transform={`rotate(${rotate},25,25)`}>\n                <rect x="10" y="10" width="30" height="30" fill="blue" />\n              </g>\n            )}\n          />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempRotate}\n          onChange={(e) => setTempRotate(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setRotate(tempRotate)\n          }}\n        >\n          Update rotation\n        </button>\n      </div>\n    </React.Fragment>\n  )\n'})},m=function(){return Object(c.jsx)(s.a,{blurb:"Custom easing functions can let you interpolate any values. Let's animate some text typing!",code:'\n  const [text, setText] = React.useState("This is some sample text")\n  const [tempText, setTempText] = React.useState(text)\n\n  return (\n    <React.Fragment>\n      <div>\n        <input\n          type="text"\n          value={tempText}\n          onChange={(e) => setTempText(e.target.value)}\n        />\n        <button\n          onClick={() => {\n            setText(tempText)\n          }}\n        >\n          Update text\n        </button>\n      </div>\n      <div>\n        <Animator\n          values={["text"]}\n          duration={5000}\n          defaultEasing={({ from, to, percent }) => {\n            let i = 0\n            while (from.charAt(i) === to.charAt(i)) {\n              i++\n            }\n            if (percent < 0.5) {\n              return from.substr(\n                0,\n                i + Math.floor((1 - percent * 2) * (from.length - i))\n              )\n            } else {\n              return to.substr(\n                0,\n                i + Math.floor((percent - 0.5) * 2 * (to.length - i))\n              )\n            }\n          }}\n        >\n          <AnimationConsumer\n            text={text}\n            render={({ text }) => <span>{text}</span>}\n          />\n        </Animator>\n      </div>\n    </React.Fragment>\n  )\n'})},_=function(){return Object(c.jsx)(s.a,{blurb:"The useInterpolate hook may make sense for your project, if you want to handle animation completely within a component.",code:'\n  const MyRef = React.useRef(({ x, y, width = 25, height = 25, fill = "blue" }) => {\n    const [interpolatedX, setInterpolatedX] = React.useState(x)\n    useInterpolate(x, setInterpolatedX)\n\n    const [interpolatedY, setInterpolatedY] = React.useState(y)\n    useInterpolate(y, setInterpolatedY)\n\n    return (\n      <rect\n        x={interpolatedX}\n        y={interpolatedY}\n        width={width}\n        height={height}\n        fill={fill}\n      />\n    )\n  })\n  const MyRect = MyRef.current\n\n  const [x, setX] = React.useState(10)\n  const [tempX, setTempX] = React.useState(x)\n  const [y, setY] = React.useState(10)\n  const [tempY, setTempY] = React.useState(y)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        <MyRect x={x} y={y} />\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempX}\n          onChange={(e) => setTempX(parseInt(e.target.value, 10))}\n        />\n        <input\n          type="text"\n          value={tempY}\n          onChange={(e) => setTempY(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setX(tempX)\n            setY(tempY)\n          }}\n        >\n          Update coordinates\n        </button>\n      </div>\n    </React.Fragment>\n  )\n'})},g=function(){return Object(c.jsx)(s.a,{blurb:"You can also animate across multiple children",code:'\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n  const [height, setHeight] = React.useState(25)\n  const [tempHeight, setTempHeight] = React.useState(height)\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        /* Pass multiple children into the Animator to interpolate them all on\n        the same props. */\n        <Animator values={["width", "height"]}>\n          <rect x="10" y="10" width={width} height={height} fill="blue" />\n          <rect x="20" y="50" width={width} height={height} fill="red" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <input\n          type="text"\n          value={tempHeight}\n          onChange={(e) => setTempHeight(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setWidth(tempWidth)\n            setHeight(tempHeight)\n          }}\n        >\n          Update dimensions\n        </button>\n      </div>\n    </React.Fragment>\n  )\n'})},v=function(){return Object(c.jsx)(s.a,{blurb:"You can set the loop flag to re-run your interpolation.",code:'\n  const [width, setWidth] = React.useState(25);\n  const [tempWidth, setTempWidth] = React.useState(width);\n  const [loop, setLoop] = React.useState(0);\n  const [tempLoop, setTempLoop] = React.useState(loop);\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        /* Just set the loop parameter on Animator or pass in a loop value to useInterpolate\'s options arg.\n           0 is the default - run it once and done.\n           -1 will loop infinitely.\n           >0 will re-run the interpolation that number of times (e.g., 5 will run 5x)\n\n           NOTE - if you are running infinitely, you will need to change the interpolated value AND the loop\n           value in order to break out of the loop.\n        */\n        <Animator values={["width"]} loop={loop}>\n          <rect x="10" y="10" width={width} height="25" fill="blue" />\n        </Animator>\n      </svg>\n      <div>\n        Loop:\n        <input\n          type="text"\n          value={tempLoop}\n          onChange={(e) => setTempLoop(e.target.value)}\n        />\n      </div>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(e.target.value)}\n        />\n        <button\n          onClick={() => {\n            setLoop(parseInt(tempLoop, 10));\n            setWidth(parseInt(tempWidth, 10));\n          }}\n        >\n          Update width\n        </button>\n      </div>\n    </React.Fragment>\n  );\n'})},b=function(){return Object(c.jsx)(s.a,{blurb:"You can also add a callback to let you know when your interpolation has finished.",code:'\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n  const [message, setMessage] = React.useState("")\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        <Animator\n          values={["width"]}\n          onCompleteCallback={({ from, to }) => {\n            setMessage(\n              `Done interpolating!\nfrom : ${JSON.stringify(\n                from,\n                undefined,\n                2\n              )}\nto : ${JSON.stringify(to, undefined, 2)}`\n            )\n          }}\n        >\n          <rect x="10" y="10" width={width} height="25" fill="blue" />\n        </Animator>\n      </svg>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => setTempWidth(parseInt(e.target.value, 10))}\n        />\n        <button\n          onClick={() => {\n            setMessage("")\n            setWidth(tempWidth)\n          }}\n        >\n          Update width\n        </button>\n      </div>\n      <div style={{ whiteSpace: "pre" }}>{message}</div>\n    </React.Fragment>\n  )\n'})},w=function(){return Object(c.jsx)(s.a,{blurb:"You can use callbacks to manage loops, too! This will animate from -> to, and then to -> from",code:'\n  const [width, setWidth] = React.useState(25)\n  const [tempWidth, setTempWidth] = React.useState(width)\n  const [loop, setLoop] = React.useState(2)\n  const [tempLoop, setTempLoop] = React.useState(loop)\n\n  // eslint-disable-next-line\n  const onCompleteCallback = ({ from, to }) => {\n    // note that for this demo, we stop BEFORE we reach 1.\n    // that\'s because we first enter this function -after- we have interpolated once.\n    // so we ignore the last loop.\n    if (loop > 1) {\n      setLoop(loop - 1)\n      setWidth(from.width)\n    }\n  }\n\n  return (\n    <React.Fragment>\n      <svg\n        viewBox="0 0 100 100"\n        xmlns="http://www.w3.org/2000/svg"\n        width="100"\n        height="100"\n      >\n        <Animator values={["width"]} onCompleteCallback={onCompleteCallback}>\n          <rect x="10" y="10" width={width} height="25" fill="blue" />\n        </Animator>\n      </svg>\n      <div>\n        Loop:\n        <input\n          type="text"\n          value={tempLoop}\n          onChange={(e) => setTempLoop(e.target.value)}\n        />\n      </div>\n      <div>\n        <input\n          type="text"\n          value={tempWidth}\n          onChange={(e) => {\n            setTempWidth(parseInt(e.target.value, 10))\n          }}\n        />\n        <button\n          onClick={() => {\n            setLoop(parseInt(tempLoop, 10))\n            setWidth(tempWidth)\n          }}\n        >\n          Update width\n        </button>\n      </div>\n    </React.Fragment>\n  )\n'})};n(18);var f=function(){return Object(c.jsxs)("div",{className:"App",children:[Object(c.jsxs)("div",{style:{gridColumnStart:"span 2"},className:"header",children:["Here are some examples of what you can do with"," ",Object(c.jsx)("a",{href:"https://github.com/thomasoniii/react-interpolation-animation",target:"_blank",rel:"noreferrer",children:"react-interpolation-animation"}),"."]}),Object(c.jsx)(u,{}),Object(c.jsx)(l,{}),Object(c.jsx)(h,{}),Object(c.jsx)(d,{}),Object(c.jsx)(g,{}),Object(c.jsx)(p,{}),Object(c.jsx)(m,{}),Object(c.jsx)(_,{}),Object(c.jsx)(v,{}),Object(c.jsx)(b,{}),Object(c.jsx)(w,{}),Object(c.jsxs)("div",{style:{gridColumnStart:"span 2"},className:"header",children:[Object(c.jsx)("div",{children:"And that's it! Have fun, and read the source if you get stuck - there are lots of comments as well as additional options that you can use to govern easing functions, initial values, and duration."}),Object(c.jsx)("div",{children:"Use either the HOC wrapper or the hook - go with whatever works easiest for your project. Enjoy!"})]})]})};r.a.render(Object(c.jsx)(i.a.StrictMode,{children:Object(c.jsx)(f,{})}),document.getElementById("root"))}],[[19,1,2]]]);
//# sourceMappingURL=main.6cefa372.chunk.js.map